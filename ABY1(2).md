* ## 概述

  * 半诚实模型下的**两方**安全计算的**混合协议框架**
  * 类似于**从底层计算协议抽象出来的虚拟机**，就像是从不同底层系统架构中抽象出来的Java虚拟机
  * 在固定长度的数据类型上进行基本运算，包括加法，乘法，比较和位运算（类似CPU的指令集）。
  * 由于有底层基本算子的支持，上层可以使用不同的高级语言来描述算法表示，这些算法最终会被转化成上述基本的运算算子
  * A用基于**beaver乘法三元组**的协议；B用**Goldreich-Micali-Wigderson (GMW)**；Y用**姚氏混淆电路协议**；
  * 由于采用了混合协议，而每一种协议具有不同的特点（比如混淆电路的交互次数是常量，GMW支持离线计算），因此在多种实际场景中，应当采取不同的协议来提升计算效率
  * 三种最重要的计算开销：![image.png](assets/image-20220311192748-c5v8gm9.png)
  * 
$$
OT^n_l
$$
代表在**
$$
l
$$
位的比特串上做n次并行**的OT
* ## Sharing Types

  * ### Arithmetic sharing

    **定义**：一个
$$
l
$$
位的数
$$
x
$$
，在整数环
$$
Z_{2^l}（整数mod2^l）
$$
上是作为**两数之和**的形式而被共享的

    * #### Sharing Semantics
    
      * 所谓分享语义就是说分享的值是怎么定义的，怎么分享，怎么恢复秘密？
      * **shared value**: 
$$
<x>_0^A=r\in Z_{2^l},<x>_1^A=x-r
$$
，
$$
<x>^A_0+<x>^A_1=x(mod 2^l)
$$

      * **sharing**：
$$
Shr^B_i(x)
$$
:
$$
P_i
$$
选择随机数 
$$
r\in_R Z_{2^l}
$$
，令 
$$
<x>_i^A=x-r
$$
，将r发送给
$$
P_{1-i}
$$
，即 
$$
<x>_{1-i}^A=r
$$

        **思考：**
$$
P_i
$$
一定是要知道x的值之后，才可以进行
$$
Shr^B_i(x)
$$
的操作。所以虽然经过
$$
Shr^B_i(x)
$$
操作之后，
$$
P_i
$$
只是持有一个子秘密，但其实
$$
P_i
$$
是知道总秘密x的真实值的
      * **reconstruction**：
$$
Rec^B_i(x)
$$
：
$$
P_i
$$
拿到另一方的子秘密，将两份子秘密相加即可还原出x。
    * #### Operations

      算术共享的几种基本运算
    
      * **ADD**:
$$
<z>^A=<x>^A+<y>^A,P_i计算<z>^A_i=<x>^A_i+<y>^A_i
$$
，加法可以直接在本地计算，不需要交互。
      * **MUL**:

$$
<z>^A=<x>^A*<y>^A
$$
，乘法无法本地单独运算，必须进行交互。每执行一次乘法，就需要预先生成一个乘法三元组
$$
<c>^A=<a>^A*<b>^A
$$

        有了这个三元组之后：
    
        * 
$$
P_i
$$
计算  
$$
<e>_i^A=<x>_i^A-<a>_i^A
$$
=和 
$$
<f>_i^A=<y>_i^A-<b>_i^A
$$

        * 双方分别执行
$$
Rec^Y_i(e)
$$
和
$$
Rec^Y_i(f)
$$
操作，将e和f还原成明文状态。
        *  
$$
P_i
$$
计算 
$$
<z>_i^A=i*e*f+f*<a>_i^A+e*<b>_i^A+<c>_i^A
$$
，乘法执行完毕。(e,f是明文，
$$
<a>_i^A,<b>_i^A,<c>_i^A
$$
由beaver三元组协议生成。下面会介绍这个等式是怎么来的以及两种生成beaver三元组的方法)
        * ##### 三元组思想

          * 
$$
z=x*y=(x-a+a)(y-b+b)
$$
，令x-a=e,y-b=f，可以得到
$$
z=ef+eb+af+ab
$$
,**注意**：等式中的e和f均是明文的形式。  
            将这个等式写成秘密共享的形式：
$$
<z>^A=ef+e*<b>^A+<a>^A*f+<a>^A*<b>^A
$$

          * 如果此时有一个乘法三元组满足
$$
<c>^A=<a>^A*<b>^A
$$
，那么此时等式：
$$
<z>^A=ef+e*(<b>_0^A+<b>_1^A)+(<a>_0^A+<a>_1^A)*f+（<c>_0^A+<c>_1^A）
$$
。
          * 观察z的形式可将其拆分为
$$
<z>_0^A=f*<a>_0^A+e*<b>_0^A+<c>_0^A，<z>_1^A=e*f+f*<a>_1^A+e*<b>_1^A+<c>_1^A
$$
，将两式统一形式可得
$$
\color{red}<z>_i^A=i*e*f+f*<a>_i^A+e*<b>_i^A+<c>_i^A
$$

      * ##### 三元组生成方法
    
        * ###### 同态加密（使用paillier加密方法）：
    
          简便起见，下述符号
$$
a，b，c
$$
默认是在算术共享下的状态。

          1. 
$$
P_0
$$
：
$$
a_0,b_0\in_R Z_{2^l}
$$

              //随机取两个数，记为
$$
a_0,b_0
$$

          2. 
$$
P_1
$$
：
$$
a_1,b_1\in_R Z_{2^l} ,r\in_R Z_{2^l} ,c_1=a_1*b_1-r
$$
<br />//随机取两个数，记为
$$
a_1,b_1
$$
。再取一个随机数r，作为
$$
a_1*b_1
$$
的噪声。
          3. 

$$
P_0 \rightarrow P_1
$$
：
$$
Enc_0(a_0),Enc_0(b_0)
$$

              //
$$
P_0
$$
用自己的公钥对
$$
a_0和b_0
$$
进行paillier加密，并且把加密之后的两个密文发送给
$$
P_1
$$

          4. 
$$
P_1 \rightarrow P_0
$$
：
$$
d=(Enc_0(a_0))^{b_1}*(Enc_0(b_0))^{a_1}*Enc_0(r)
$$

              //
$$
P_1
$$
收到了两个密文之后，用自己的
$$
b_1、a_1和r
$$
，计算如上所示的d，并且把d发送给
$$
P_0
$$
。  
              //这一步其实是利用了paillier加密的一个性质（用E()代表加密操作）：
$$
E(a+b)=E(a)*E(b),E(ab)=E(a)^b
$$
,所以这一步的
$$
d=Enc_0(a_0*b_1+b_0*a_1+r)
$$

          5. 
$$
P_0
$$
：
$$
c_0=a_0*b_0+Dec_0(d)
$$

              //最后，P_0拿到d之后，用自己的私钥进行解密可得
$$
Dec_0(d)=a_0*b_1+b_0*a_1+r
$$
，那么
$$
c_0=a_0*b_0+a_0*b_1+b_0*a_1+r
$$
。  
              此时，验证
$$
c_0+c_1=a_0*b_0+a_0*b_1+b_0*a_1+r+a_1*b_1-r=a_0*b_0+a_0*b_1+b_0*a_1+a_1*b_1=(a_0+a_1)(b_0+b_1)=a*b
$$
，正确。
        * ###### OT：

          基于OT的方法会稍微复杂一些，具体来看：
    
          * 
$$
<a>^A*<b>^A=<a>^A_0*<b>^A_0+<a>^A_0*<b>^A_1+<b>^A_0*<a>^A_1+<a>^A_1*<b>^A_1
$$
，其中第一项和第四项可以分别由
$$
P_0
$$
，
$$
P_1
$$
在本地进行计算，困难在于第二第三项的乘法交叉项。以计算
$$
u=<a_0b_1>^A
$$
为例,计算乘法交叉项
$$
<a_1b_0>^A
$$
也是同样的方法。为了防止信息泄密，u也需要作为一个总秘密，分别被
$$
P_0,P_1
$$
两方持有。下面来说
$$
P_0
$$
和
$$
P_1
$$
如何分别得到
$$
u_0
$$
和
$$
u_1
$$
：
          * 这个方法的大体的思路是
$$
P_0
$$
作为发送方，
$$
P_1
$$
作为接收方，总共进行
$$
l
$$
次关联OT。将
$$
b_1
$$
进行位分解，每一次OT传输的就是b1第i个比特的值。
          * 
$$
s_{i,0}
$$
是一个任意的
$$
l
$$
位的数，
$$
s_{i,1}=<a>_0*2^i+s_{i,0}
$$
，在第i次关联OT的过程中，
$$
P_0
$$
将
$$
s_{i,0}和s_{i,1}
$$
发送给
$$
P_1
$$
，
$$
P_1
$$
根据自己的子秘密
$$
<b>_1
$$
第i位上的比特值作为**选择比特**，拿到
$$
\color{red}s_{i,<b>_1[i]}=<b>_1[i]*2^i*<a>_0+s_{i,0}
$$
（这里的
$$
s_{i,0}
$$
是
$$
P_0
$$
加的噪声），按照这个过程执行
$$
l
$$
次C-OT之后，令
$$
u_1=\sum_{i=0}^{l-1}s_{i,<b>_1[i]}=\sum_{i=0}^{l-1}(<b>_1[i]*2^i*<a>_0+s_{i,0})=<a>_0\sum_{i=0}^{l-1}<b>_1[i]*2^i+\sum_{i=0}^{l-1}s_{i,0}=<a>_0<b>_1+\sum_{i=0}^{l-1}s_{i,0}
$$
（**注**：
$$
\sum_{i=0}^{l-1}<b>_1[i]*2^i=<b>_1
$$
），让
$$
<u>_0
$$
等于
$$
\sum^{l-1}_{i=0}(-s_{i,0})
$$
,这样
$$
<u>_0+<u>_1=<u>=<a_0b_1>
$$
。按照相同的方法可以得到
$$
<v>^A=<a_1b_0>^A
$$
，最后，
$$
P_i
$$
可令
$$
<c>_i^A=<a>_i^A<b>_i^A+<u>_i^A+<v>_i^A
$$
，这样就生成了三元组
$$
<c>^A=<a>^A*<b>^A
$$

          * 便于理解，这里对论文中
$$
s_{i,1}和<u>_0
$$
的形式进行了修改，如果
$$
<b>_1[i]
$$
=0，那么作为选择比特，
$$
P_1
$$
应该接收到
$$
s_{i,0}
$$
而不是
$$
-s_{i,0}
$$
。
  * ### Boolean Sharing

    * **定义**：在比特上的异或（XOR，
$$
\oplus
$$
）秘密分享。
    * #### Sharing Semantics

      * **shared values**. 一个布尔秘密共享
$$
<x>^B
$$
是作为一个比特在两方之间共享的，对于
$$
P_0,P_1
$$
两方的子秘密，有
$$
<x>_0^B\oplus <x>_1^B=x,\quad <x>_0^B,<x>_1^B\in Z_{2}
$$

      * **sharing.** 
$$
Shr_i^B(x):﻿P_i
$$
选择一个任意比特r，并计算
$$
<x>_i^B=x\oplus r
$$
，之后将r发送给
$$
P_{1-i}
$$
，则
$$
<x>_{1-i}^B=r
$$

      * **reconstruction**. 
$$
Rec^B_i(x)
$$
：
$$
P_i
$$
拿到另一方的子秘密，进行异或操作即可恢复秘密。
    * #### Operations

      * 其实和算术共享arithmetic sharing是一模一样的，只不过运算域不同，算术共享是在环
$$
Z_{2^l}
$$
上进行运算，而布尔共享是在环
$$
Z_2
$$
上运算。在
$$
Z_2
$$
这个代数系统下，加法（ADD）等同于异或（XOR），乘法（MUL）等同于相与（AND）。
      * **XOR**:可以理解为算术共享下的加法操作。本地即可运算，无需交互。
      * **AND**:除了可以用算术共享的思路去生成比特三元组
$$
<c>^B=<a>^B \wedge <b>^B
$$
，进而完成
$$
<z>^B=<x>^B \wedge <y>^B
$$
。也可以用GMW[^1]协议来完成相与操作（正好就是GMW运行的过程）。
      * **MUX**:多路选择，三目运算。即 MUX(x,y,b)如果比特 b=0则返回 x，否则返回 y,可以用随机OT（R-OT）实现。
  * ### Yao's Sharing

    * 姚氏共享使用姚氏混淆电路[^2]协议，其利用布尔电路（boolean circuits）进行计算。
    * 姚氏共享和之前算术共享、布尔共享最大的不同就在于参与计算的两方并不是平等的关系，这是由姚氏混淆电路协议（之后简称为YGC（Yao's Garbled Circuit））的特点决定的。假设
$$
P_0
$$
作为Garbler混淆方，负责生成整个电路的真值表并将其加密、打乱，加密打乱之后的真值表叫做混淆表，
$$
P_0
$$
将混淆表发送给Evaluator运算方
$$
P_1
$$
。
$$
P_1
$$
根据两方输入所对应的label以及收到的混淆表进行运算和解密，得出最终结果所对应的label。
    * 在YGC的基础上，采用了**free-XOR**和**point-and-permute**优化技术优化[^4]，具体来说，P_0在生成混乱表的时候可以选择一个全局的、随机的k比特长度的串R，作为全局的偏移量，并且最后一位（或者说LSB）为1，这样，对于布尔电路中的每一条线w，对应的密钥就可以设置为
$$
k_0^w\in _R\{0,1\}^k,k_1^w=k_0^w\oplus R
$$
。这样的设置一方面满足free- XOR技术的要求，另一方面也满足
$$
1-k_0^w[0]=k_1^w[0]
$$
，0，1对应的两个label的最低有效位（LSB）互为相反数。
    * 分享秘密x时，有
$$
<x>_0^Y=k_0(没有标明上标就代表着电路中每一条线的0对应的label)，<x>_1^Y=k_0\oplus xR=k_x
$$

    * 论文中拿一比特来举例说明，多比特可以串行或者使用并行技术运行
$$
l
$$
次，一个道理。
    * #### sharing semantics:

      * **shared value**:
$$
<x>_0^Y=k_0,<x>_1^Y=k_0\oplus xR=k_x
$$


​        
$$
P_0
$$
持有所有线路（w）的两个label，并且知道对应关系，
$$
P_1
$$
只持有任意一个label，且不知道label对应的是0还是1
      * **sharing**：因为参与双方地位不平等，所以会有两种不同的分享操作。

        * 
$$
Shr^Y_0(x)
$$
是
$$
P_0
$$
首先在本地生成 
$$
k_0^w\in _R\{0,1\}^k
$$
，计算并发送 
$$
k_x=k_0\oplus xR
$$
给
$$
P_1
$$
。
        * 
$$
Shr^Y_1(x)
$$
则是双方进行C-OT，其中
$$
P_0
$$
输入关联函数 
$$
f_R(x)=(x\oplus R)
$$
并获得 
$$
k_0,k_1=k_0\oplus k_1
$$
，其中 
$$
k_0\in _R\{0,1\}^k
$$
，
$$
P_1
$$
作为接收者输入选择比特 x 并获得 
$$
<x>_1^Y=k_x
$$
（要明白估算方做这个分享操作的时候只是知道x的值，但是自己作为
$$
P_1
$$
，永远只是持有一个未知的label（除非他之前已知了这个秘密），做这个分享的时候它自然是知道秘密的值的）
      * **reconstruction**：
$$
Rec^Y_i(x)
$$
：恢复秘密则需要 
$$
P_{1-i}
$$
将 
$$
\pi=<x>_{1-i}^Y[0]
$$
发送给
$$
P_i
$$
，
$$
P_i
$$
计算 
$$
x=\pi\oplus <x>_{i}^Y[0]
$$

    * #### operations:
    
      在一些AND和XOR门组成的布尔电路上进行运算，这两个门进而可以组成一系列更加复杂的逻辑运算电路
    
      * **XOR**：利用free-XOR优化技术，可以本地计算
$$
<z>^Y_i=<x>^Y_i\oplus <y>^Y_i
$$
。
      * **AND**：
$$
<z>^Y=<x>^Y\wedge <y>^Y
$$
.
$$
P_0
$$
用自己的两个子秘密去加密
$$
z_0
$$
，得到混乱表 
$$
Gb_{<z>^Y_0}(<x>^Y_0,<y>_0^Y)
$$
，
$$
P_1
$$
拿到混淆表再用自己的两个子秘密去解密即可获得
$$
z_1
$$
。这里Gb函数没有讲清楚，引用论文里也没有说清楚，计划后续阅读源码了解细节[^3]
    * #### State-of-the-Art:

      * 针对YGC的，除了上述两项优化技术之外，还有Row reduction和pipelining（混淆表在线阶段发送），但是论文没有使用pipelining优化技术，因为作者想要减少**在线阶段**的复杂度，因此要在**设置阶段**产生和传输混淆电路和混淆表；
* ## Sharing Conversions

  * 上述三种sharing各有自己的优缺点，因此在应用过程中要根据实际情况结合这三种技术，充分发挥它们各自的优势，回避劣势，提高整体的性能。下面来将这三种sharing之间的转化。
  * ### Yao to Boolean Sharing (Y2B)

    * 因为（ 
$$
<x>^Y_0,<x>^Y_1
$$
）的置换位已经构成了一对布尔共享（回顾一下姚氏共享和布尔共享的两个子秘密是怎么还原出x的：
$$
x=<x>_{1-i}^Y[0]\oplus <x>_{i}^Y[0],<x>_0^B\oplus <x>_1^B=x
$$
），所以
$$
P_i
$$
可以在本地令
$$
<x>^B_i=Y2B(<x>^Y_i)=<x>^Y_i[0]
$$
，Y2B因为有着几乎没有开销的性质，所以一些其他的转化可以利用这一点性质来减少开销，具体细节见下文。
  * ### Boolean to Yao Sharing (B2Y)

    * 这个转化过程和 
$$
Shr_1^Y
$$
很相似。记 
$$
x_0=<x>_0^B,x_1=<x>_1^B
$$
。
$$
P_0
$$
取 
$$
<x>_0^Y=k_0\in _R\{0,1\}^k
$$
。两方随后执行OT，
$$
P_0
$$
作为发送者输入 
$$
(k_0\oplus x_0*R,k_0\oplus (1-x_0)\cdot R)
$$
,
$$
P_1
$$
作为接收者输入
$$
x_1
$$
作为选择比特获得 
$$
<x>_1^Y=k_0\oplus (x_0\oplus x_1)\cdot R=k_0\oplus x\cdot R=k_x
$$
(OT过程：
$$
x_1
$$
是0就选第0条消息，是1就选第1条)
  * ### Arithmetic to  Yao Sharing (A2Y)

    * 在姚氏共享的加法电路下完成，两方执行
$$
Shr_0^Y(<x>_0^A)和Shr_1^Y(<x>_1^A)
$$
（这两个操作的含义是将x算术共享下的子秘密作为一个新的秘密，再去做一个分享） 得到 
$$
<<x>_0^A﻿>^Y
$$
（**注意**这是一个总秘密的形式，代表着两个子秘密置换位的异或。要清楚这里的每一个**上下标的含义**，才能明白这个操作是在干什么）和 
$$
<<x>_1^A﻿>^Y
$$
，最终在姚氏共享状态下计算加法
$$
<x>^Y=<<x>_0^A﻿>^Y+<<x>_1^A﻿>^Y
$$
，这里写成
$$
<x>^Y_i=<<x>_0^A﻿>^Y_i+<<x>_1^A﻿>^Y_i
$$
会更好理解一些。
  * ### Arithmetic to Boolean Sharing (A2B)

    * 与A2Y类似，A2B同样可以采取在布尔共享下做加法完成——双方各自以自己的子秘密做一次布尔共享，得到
$$
<<x>^A_0>^B
$$
和
$$
<<x>^A_1>^B
$$
，二者相加就是
$$
<x>^B
$$
，**但是**这个加法是密文下的进位加法，不考虑优化的情况之下每一次加法要进行两次与操作，开销极大;或者是使用算术比特抽取电路来完成，开销同样很大。
    * 由于Y2B没有开销，而Yao Sharing在做加法时比Boolean Sharing更加高效，因此使用 
$$
Y2B(A2Y(<x>^A))
$$
来实现
$$
A2B(<x>^A)
$$
（就是先把算术共享转化成姚氏共享，再从姚氏共享转化成布尔共享）
  * ### Boolean to Arithmetic Sharing (B2A)

    * 可以通过Boolean 电路上的减法实现，
$$
<x>^A_0
$$
=r,r是任意
$$
l
$$
长度的比特串，
$$
<x>^A_1
$$
=x-r（~~我的理解是
$$
P_0
$$
把
$$
<x>^B_0-r
$$
发给
$$
P_1
$$
，
$$
P_1
$$
收到之后加上自己的
$$
<x>^B_1
$$
就得到
$$
<x>^A_1
$$
~~。还是不太一样，这个**减法不是在本地做的，而是共同向一个减法电路**输入
$$
x_0^B,x_0^A和x_1^B
$$
,之后
$$
P_1
$$
才能得到
$$
<x>_1^A
$$
。再具体就要看这个减法电路的细节了）。但是这种方法开销太大。
    * 常用的做法是使用OT，思路和使用OT生成beaver三元组是一样的。在第i次OT，
$$
P_0
$$
任意选择一个
$$
l
$$
长度的比特串
$$
r_i
$$
，之后作为发送方输入 
$$
(s_{i,0},s_{i,1})
$$


       满足 
$$
s_{i,0}=<x>_0^B[0]\cdot 2^i-r_i,s_{i,1}=(1-<x>_0^B[0])\cdot 2^i-r_i
$$
。
$$
P_1
$$
作为接受方输入 
$$
<x>_1^B[i]
$$
作为选择比特得到 
$$
s_{i,<x>_1^B[i]}=(<x>_0^B[0]\oplus <x>_1^B[0])\cdot 2^i-r_i
$$
。最终，
$$
P_0
$$
本地计算得到
$$
<x>_0^A=\sum_{i=0}^{l-1}r_i
$$
 ，
$$
P_1
$$
本地计算 
$$
<x>_1^A=\sum_{i=0}^{l-1}s_{i,<x>_1^B[i]}=\sum_{i=0}^{l-1}(<x>_0^B[i]\oplus <x>_1^B[i])\cdot 2^i-\sum_{i=0}^{l-1}r_i=x-<x>_0^A
$$
。从而完成B2A转换。
  * ### Y2A

    * 一个方法是在姚氏共享下运算减法：
$$
P_0
$$
随机选择 
$$
r\in _RZ_{2^l}
$$
并执行
$$
Shr_0^Y(r)
$$
 (让
$$
P_1
$$
得到
$$
r_1
$$
)。进一步，两方计算
$$
<d>^Y=<x>^Y-<r>^Y
$$
 ，
$$
P_0
$$
揭示
$$
d_0
$$
给
$$
P_1
$$
。最终，
$$
<x>_0^A=r,<x>_1^A=d
$$
  。但这种方法需要在Yao Sharing下执行Boolean 减法电路，开销极大。
    * B2A的开销比上述减法的开销要小很多，因此可以利用 
$$
B2A(Y2B(<x>^Y))
$$
实现 
$$
Y2A(<x>^Y)
$$
。
  * ### 开销总结：

    * ![image.png](assets/image-20220318145356-afhxcy6.png)
* ## 总结

  * 技术细节如上所述，现在从宏观上来谈一谈三种共享各自的特点：
  * ### 算术共享

    * 适合进行加法和乘法的算术运算
    * 支持加法乘法运算，不支持判等和比较
    * 之前有一些安全计算协议有支持算术共享下的EQ（判等）和CMP（比较）操作的，但是不如进行共享转化A2Y之后，进行EQ操作和CMP操作之后，再Y2A快。
  * ### 布尔共享

    * 多路选择(MUX)最快
    * 在网络延迟较好的环境下，非算术运算比姚氏快
  * ### 姚氏共享

    * 比较(CMP)最快
    * 在网络延迟较高的情况下，非算术运算比布尔快
  * ### 宏观特点

    来自于ABY2论文当中的一句话：

    * 纵观多数MPC的协议，都可以分成两类：

      * 低延迟：使用姚氏共享——固定的通信轮数
      * 高吞吐：使用秘密共享——通信轮数和电路深度相关

[^1]: # GMW

    * ## 与YGC异同
    
      * 都是运行在一个逻辑门电路之上的。
      * Y有混淆真值表的过程，G 无需加密
      * Y靠运算方拿着两个label一步步解密得到结果，在线阶段要进行大量的运算，但是只交互固定的轮次就可以得到结果；而G靠一方事先枚举出每个门的四种输出，另一方通过1-out-of-4 OT得到正确的输出（正确结果经过加噪声的），中间需要多次的交互，但是在线阶段无需进行枚举的运算。
      * Y用的是对称加密，G所用的OT采用了公钥加密（同态加密）计算复杂度较高
      * [GMW介绍](https://zhuanlan.zhihu.com/p/237061306) [GC介绍](https://www.mrccc.club/2021/08/garbled-circuitsjieshao-2/)
    * ## 协议过程
    
      {{{col
      * GMW只有三种操作，子秘密三种操作（AND,XOR,NOT）中的异或和非操作都可以在本地完成，无需交互，此处说一下做与操作的情况。
    
      }}}
    
      1. 子秘密生成（中间过程就不用考虑这一步了）：方式和布尔共享的
$$
Shr(x) 
$$
操作类似
      2. A**随机生成**
$$
z_a\in \{0,1\}
$$
，并枚举 
$$
f(x_b,y_b)=z_a\oplus G(x_a\oplus x_b,y_a\oplus y_b)
$$
（这里的G()可以是一些有着复杂功能的函数，当然也可以是AND函数）的所有可能值。由于 
$$
x_b,y_b\in \{0,1\}
$$
，所以 
$$
f(x_b,y_b)
$$
一共有四个可能值，即 
$$
\{f(0,0),f(0,1),f(1,0),f(1,1)\}
$$

      3. 双方进行
$$
OT_1^4
$$
（初始输入时是1-out-of-2OT），A提供真值表，B提供自己的子秘密作为选择索引，得到了
$$
f(x_b,y_b)
$$
，记为
$$
z_b
$$

      4. 二者通信，
$$
z_a
$$
和
$$
z_b
$$
异或即可解密

      * 在更复杂的电路的情况下，A、B均可以根据上述方法来计算每一个逻辑门的输出，中间过程中每一个门的输入都作为秘密被两方所共享，所以也不会泄密，到最后一步输出结果时，双方进行Rec()操作，恢复秘密即可。


[^2]: # 姚氏混淆电路

    * 在混淆电路的协议中，函数是被描述为**布尔电路**的
    * 要举反例的话，用**与门**即可
    * 资料来自于[Wiki](https://en.wikipedia.org/wiki/Garbled_circuit#Point-and-permute)、[GC介绍](https://www.mrccc.club/2021/08/garbled-circuitsjieshao-2/)、[课程笔记](https://www.zhihu.com/column/c_1380808297608613888)
    * ## 协议由六步组成
    
      1. 函数（百万富翁问题里就是比较函数）由两输入门的布尔电路所表示，![image.png](assets/image-20220506163341-dlwz038.png)，**电路结构透明**，第一步事先可由第三方完成。
      2. A方混淆（加密和打乱）电路，称为混淆方
      3. A把混淆电路和自己编码加密后的输入label发给B
      4. B通过OT从A拿到自己的输入的编码加密形式（label）
      5. B根据手里的两个label（可以理解为两把钥匙）去解密真值表，最终获得真值的加密形式（label）
      6. A和B交互，解密label，获得最终的输出结果。
    * ## 电路生成
    
      生成电路时很重要的一点就是要使用尽可能少的AND门，尽可能地用XOR门去实现函数的功能(根据 FREE-XOR优化，XOR门几乎没有开销)
    
      todo[^3]
    * ## 混淆过程
    
      * A为电路的每一条线都随机生成两个K（K代表安全参数，一般为128）长度的比特串（叫做label），一个代表1，另一个代表0，输出label的形式可能会特殊些。
      * 用label去替换真值表中的值
      * 用每一行的两个输入label去加密输出label，得到混淆表。![image.png](assets/image-20220308201938-62u4cgf.png "混淆表")
      * B只有拿到对应的两个输入label才可以解出输出label。
    * ## 数据传输
    
      A要把电路里所有门的混淆表发给B；通过OT把B输入所对应的label发给B；把自己输入所对应的label发给B，举例说明，如果A的输入
$$
a=a_2a_1a_0=100
$$
,那么A发给B的其实是：


$$

$$

      X_{1}^{a_{2}},X_{0}^{a_{1}},X_{0}^{a_{0}}

$$

$$

    * ## 计算
    
      * 原始协议的情况下，B拿着两个label去一个一个尝试去解密混淆表，最终得到输出label
    * ## 输出结果
    
      * 最终的label与label的对应关系分别在B和A手中，相互通信即可解出结果
    * ## 优化
    
      姚期智教授提出姚氏混淆电路协议之后，有很多专家和学者对其进行了优化。
    
      * ### point-and-permute
    
        * 随机取每条线的label的最后一位为置换位（permutation-bit）,布尔电路中同一条线上两个label的置换位互为反码。
        * eg：输入线A的输入对应的label的置换位为s0;B对应的为s1。那么对应的混淆表的项会被放在第（2*s0+s1）行，B方拿到两个label，看一下置换位的两个数字就知道去解密哪一行了。因此大大减小了解密的时间。
      * ### free-XOR
    
        * 顾名思义，异或门开销极小，甚至可以忽略不计。(做一次异或 versus  加密、混淆再解密)
        * #### 步骤
    
          * 定义所有XOR门输入线路的label--W的偏移量ΔW（全局的、随机的）
          * 设A,B分别表示两条输入线路上真值为FALSE的标签, C表示输出线路上真值为FALSE的标签, 则输入线路的标签可分别表示为
$$
(A，A \oplus \Delta),(B，B \oplus \Delta)
$$
, 而输出标签可表示为
$$
(C，C \oplus \Delta)=((A\oplus B，A\oplus B \oplus \Delta))
$$

          * 如此一来, Garbler无需加密输出标签, 而Evaluator计算输出标签只需将收到的输入标签直接XOR在一起即可, 无需任何解密运算，相较于之前加密在解密的步骤，代价可以看作是free
          * 不能再使用原来的伪随机数生成器了，得改用RO（random Oracle）随机预言机。这样在半诚实模型下才是安全的。
      * [row reduction](https://zhuanlan.zhihu.com/p/375296212)


[^3]: # todo

    。


[^4]: ## 优化

    姚期智教授提出姚氏混淆电路协议之后，有很多专家和学者对其进行了优化。
    
    * ### point-and-permute
    
      * 随机取每条线的label的最后一位为置换位（permutation-bit）,布尔电路中同一条线上两个label的置换位互为反码。
      * eg：输入线A的输入对应的label的置换位为s0;B对应的为s1。那么对应的混淆表的项会被放在第（2*s0+s1）行，B方拿到两个label，看一下置换位的两个数字就知道去解密哪一行了。因此大大减小了解密的时间。
    * ### free-XOR
    
      * 顾名思义，异或门开销极小，甚至可以忽略不计。(做一次异或 versus  加密、混淆再解密)
      * #### 步骤
    
        * 定义所有XOR门输入线路的label--W的偏移量ΔW（全局的、随机的）
        * 设A,B分别表示两条输入线路上真值为FALSE的标签, C表示输出线路上真值为FALSE的标签, 则输入线路的标签可分别表示为
$$
(A，A \oplus \Delta),(B，B \oplus \Delta)
$$
, 而输出标签可表示为
$$
(C，C \oplus \Delta)=((A\oplus B，A\oplus B \oplus \Delta))
$$

        * 如此一来, Garbler无需加密输出标签, 而Evaluator计算输出标签只需将收到的输入标签直接XOR在一起即可, 无需任何解密运算，相较于之前加密在解密的步骤，代价可以看作是free
        * 不能再使用原来的伪随机数生成器了，得改用RO（random Oracle）随机预言机。这样在半诚实模型下才是安全的。
    * [row reduction](https://zhuanlan.zhihu.com/p/375296212)
